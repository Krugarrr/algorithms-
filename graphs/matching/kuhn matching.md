# Алгоритм Куна для поиска максимального паросочетания

<b>Алгоритм Куна</b> — непосредственное применение теоремы Бержа. Его можно кратко описать так: сначала возьмём пустое паросочетание, а потом — пока в графе удаётся найти увеличивающую цепь, — будем выполнять чередование паросочетания вдоль этой цепи, и повторять процесс поиска увеличивающей цепи. Как только такую цепь найти не удалось — процесс останавливаем, — текущее паросочетание и есть максимальное.

Словами попроще: запускаем поиск пути из произвольной свободной вершины из левой доли в какую-нибудь свободную вершину правой доли в том же графе, но в котором из правой доли можно идти только по рёбрам паросочетания (то есть у вершин правой доли будет либо одно ребро, либо ноль). Это можно делать как угодно, однако устоялась эффективная реализация в виде dfs на 20 строчек кода, приведённая ниже.

```cpp
const int maxn;

vector<int> g[maxn]; // будем хранить только рёбра из левой доли в правую

int mt[maxn]; // с какой вершиной сматчена вершина правой доли (-1, если ни с какой)

bool used[maxn]; // вспомогательный массив для поиска пути dfs-ом


// dfs возвращает, можно ли найти путь из вершины v
// в какую-нибудь вершину правой доли
// если можно, то ещё и проводит чередование
bool kuhn(int v) {
    if (used[v])
        return false;
    used[v] = true;
    for (int u : g[v]) {
        // если вершина свободна, то можно сразу с ней соединиться

        // если она занята, то с ней можно соединиться только тогда,
        // когда из её текущей пары можно найти какую-нибудь другую вершину
        if (mt[u] == -1 || kuhn(mt[u])) {
            mt[u] = v;
            return true;
        }
    }
    return false;
}


// где-то в main:

int main() {
    //читаем граф

	mt.assign (k, -1);
	for (int v=0; v<n; ++v) {
		used.assign (n, false);
		kuhn (v);
	}
 
	for (int i=0; i<k; ++i)
		if (mt[i] != -1)
			cout << (mt[i]+1, i+1, "\n");
}
```
## Асимптотика
Алгоритм ровно $V$ раз ищет увеличивающий путь, каждый раз просматривая не $E$ более рёбер, а значит работает за $O(VE)$.